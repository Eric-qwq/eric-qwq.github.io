<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>下落式節奏遊戲</title>
<style>
body {
margin: 0;
padding: 0;
background-color: #000;
color: #fff;
font-family: sans-serif;
text-align: center;
overflow: hidden;
}
#game-container {
position: relative;
width: 100vw;
height: 100vh;
max-width: 450px; /* 限制最大寬度以適應手機螢幕 /
margin: 0 auto;
background-color: #111;
overflow: hidden;
}
#note-lanes {
position: absolute;
bottom: 0;
width: 100%;
height: 100%;
display: flex;
}
.lane {
flex-grow: 1;
border-left: 1px solid #444;
border-right: 1px solid #444;
box-sizing: border-box;
position: relative;
}
.note {
position: absolute;
width: 100%;
height: 25px;
background-color: #3f51b5; / 藍色音符 */
will-change: top;
}
#judgement-line {
position: absolute;
bottom: 15%;
width: 100%;
height: 5px;
background-color: rgba(255, 255, 255, 0.8);
box-shadow: 0px 0px 10px 3px #fff;
}
.judgement-feedback {
position: absolute;
left: 50%;
top: 40%;
transform: translateX(-50%);
font-size: 3em;
font-weight: bold;
opacity: 0;
animation: fade-out 0.5s forwards;
}
@keyframes fade-out {
from { opacity: 1; transform: translateX(-50%) scale(1.2); }
to { opacity: 0; transform: translateX(-50%) scale(1); }
}
#score-display {
position: absolute;
top: 20px;
left: 50%;
transform: translateX(-50%);
font-size: 2em;
z-index: 10;
}
#start-screen, #end-screen {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
justify-content: center;
align-items: center;
z-index: 20;
}
#start-screen h1, #end-screen h1 {
font-size: 2.5em;
margin-bottom: 20px;
}
#end-screen p {
font-size: 1.5em;
margin-bottom: 30px;
}
.button {
padding: 15px 30px;
font-size: 1.5em;
background-color: #3f51b5;
color: white;
border: none;
border-radius: 10px;
cursor: pointer;
transition: background-color 0.3s;
}
.button:hover {
background-color: #303f9f;
}
</style>
</head>
<body>
<div id="game-container">
<div id="start-screen">
<h1>下落式節奏遊戲</h1>
<button id="start-button" class="button">開始遊戲</button>
</div>
<div id="end-screen" style="display: none;">
<h1>遊戲結束</h1>
<p id="final-score"></p>
<button id="restart-button" class="button">重新開始</button>
</div>
<div id="score-display">Score: 0</div>
<div id="note-lanes">
    <div class="lane" id="lane-0"></div>
    <div class="lane" id="lane-1"></div>
    <div class="lane" id="lane-2"></div>
    <div class="lane" id="lane-3"></div>
</div>
<div id="judgement-line"></div>

</div>
<audio id="music" src="https://dl.dropboxusercontent.com/s/g8a13aa3zsd4i24/sample-music.mp3" preload="auto"></audio>
<script>
document.addEventListener('DOMContentLoaded', () => {
const gameContainer = document.getElementById('game-container');
const lanes = document.querySelectorAll('.lane');
const judgementLine = document.getElementById('judgement-line');
const scoreDisplay = document.getElementById('score-display');
const startScreen = document.getElementById('start-screen');
const endScreen = document.getElementById('end-screen');
const startButton = document.getElementById('start-button');
const restartButton = document.getElementById('restart-button');
const finalScoreDisplay = document.getElementById('final-score');
const music = document.getElementById('music');
const NOTE_SPEED = 350; // pixels per second
const JUDGEMENT_OFFSET_MS = 100; // ms, a larger value means you need to tap earlier

// Beatmap: time (in seconds) and the lane (0-3)
const beatmap = [
    { time: 1.0, lane: 0 }, { time: 1.5, lane: 1 }, { time: 2.0, lane: 2 }, { time: 2.5, lane: 3 },
    { time: 3.2, lane: 0 }, { time: 3.4, lane: 2 }, { time: 4.0, lane: 1 }, { time: 4.5, lane: 3 },
    { time: 5.0, lane: 0 }, { time: 5.0, lane: 2 }, { time: 5.8, lane: 1 }, { time: 6.3, lane: 3 },
    { time: 7.0, lane: 0 }, { time: 7.2, lane: 1 }, { time: 7.4, lane: 2 }, { time: 7.6, lane: 3 },
    { time: 8.5, lane: 0 }, { time: 8.5, lane: 3 }, { time: 9.3, lane: 1 }, { time: 9.3, lane: 2 },
    { time: 10.1, lane: 0 }, { time: 10.6, lane: 1 }, { time: 11.1, lane: 2 }, { time: 11.6, lane: 3 },
    { time: 12.0, lane: 0 }, { time: 12.2, lane: 2 }, { time: 12.4, lane: 1 }, { time: 12.6, lane: 3 },
    { time: 13.5, lane: 0 }, { time: 13.5, lane: 1 }, { time: 14.0, lane: 2 }, { time: 14.0, lane: 3 },
    { time: 15.0, lane: 0 }, { time: 15.25, lane: 1 }, { time: 15.5, lane: 2 }, { time: 15.75, lane: 3 },
    { time: 16.0, lane: 0 }, { time: 16.25, lane: 1 }, { time: 16.5, lane: 2 }, { time: 16.75, lane: 3 },
    // ...add more notes for the rest of the song
];

let score = 0;
let noteIndex = 0;
let activeNotes = [];
let gameStartTime = 0;
let animationFrameId;
let isGameRunning = false;

function createNote(laneIndex) {
    const note = document.createElement(&#39;div&#39;);
    note.className = &#39;note&#39;;
    note.style.top = &#39;-25px&#39;; // Start above the screen
    lanes[laneIndex].appendChild(note);

    const spawnTime = music.currentTime;
    const noteData = {
        element: note,
        lane: laneIndex,
        spawnTime: spawnTime,
        targetTime: spawnTime + (gameContainer.clientHeight / NOTE_SPEED)
    };
    activeNotes.push(noteData);
}

function updateGame() {
    if (!isGameRunning) return;

    const currentTime = music.currentTime;
    
    // Spawn new notes based on beatmap
    while (noteIndex &lt; beatmap.length &amp;&amp; currentTime &gt;= beatmap[noteIndex].time - (gameContainer.clientHeight / NOTE_SPEED)) {
        const noteInfo = beatmap[noteIndex];
        createNote(noteInfo.lane);
        noteIndex++;
    }

    const judgementLineY = judgementLine.offsetTop;

    // Move active notes and check for misses
    for (let i = activeNotes.length - 1; i &gt;= 0; i--) {
        const noteData = activeNotes[i];
        const elapsedTime = currentTime - noteData.spawnTime;
        const newY = elapsedTime * NOTE_SPEED;

        noteData.element.style.top = `${newY}px`;

        // Check for miss (note passed the judgement line)
        if (newY &gt; judgementLineY + 20) {
            lanes[noteData.lane].removeChild(noteData.element);
            activeNotes.splice(i, 1);
            showJudgementFeedback(&#39;Miss&#39;);
        }
    }

    if (music.ended) {
        endGame();
    } else {
        animationFrameId = requestAnimationFrame(updateGame);
    }
}

function handleInput(laneIndex) {
    if (!isGameRunning) return;

    const judgementLineY = judgementLine.offsetTop;
    let bestCandidate = null;
    let minDistance = Infinity;

    // Find the closest note in the tapped lane
    for (const noteData of activeNotes) {
        if (noteData.lane === laneIndex) {
            const noteY = noteData.element.offsetTop + (noteData.element.clientHeight / 2);
            const distance = Math.abs(noteY - judgementLineY);
            
            if (distance &lt; minDistance) {
                minDistance = distance;
                bestCandidate = noteData;
            }
        }
    }
    
    if (bestCandidate) {
        const distance = Math.abs(bestCandidate.element.offsetTop + (bestCandidate.element.clientHeight / 2) - judgementLineY);
        
        let judgement = &#39;&#39;;
        if (distance &lt; 30) {
            judgement = &#39;Perfect&#39;;
            score += 100;
        } else if (distance &lt; 60) {
            judgement = &#39;Good&#39;;
            score += 50;
        } else {
            judgement = &#39;Bad&#39;;
        }
        
        showJudgementFeedback(judgement);
        scoreDisplay.textContent = `Score: ${score}`;
        
        // Remove the hit note
        bestCandidate.element.remove();
        activeNotes = activeNotes.filter(n =&gt; n !== bestCandidate);
    }
}

function showJudgementFeedback(text) {
    const feedback = document.createElement(&#39;div&#39;);
    feedback.className = &#39;judgement-feedback&#39;;
    feedback.textContent = text;

    if (text === &#39;Perfect&#39;) feedback.style.color = &#39;#4caf50&#39;; // Green
    else if (text === &#39;Good&#39;) feedback.style.color = &#39;#ffeb3b&#39;; // Yellow
    else if (text === &#39;Bad&#39;) feedback.style.color = &#39;#f44336&#39;; // Red
    else if (text === &#39;Miss&#39;) feedback.style.color = &#39;#9e9e9e&#39;; // Grey

    gameContainer.appendChild(feedback);
    
    setTimeout(() =&gt; {
        feedback.remove();
    }, 500);
}

function resetGame() {
    score = 0;
    noteIndex = 0;
    activeNotes.forEach(noteData =&gt; noteData.element.remove());
    activeNotes = [];
    scoreDisplay.textContent = &#39;Score: 0&#39;;
    music.currentTime = 0;
    isGameRunning = false;
    cancelAnimationFrame(animationFrameId);
}

function startGame() {
    resetGame();
    startScreen.style.display = &#39;none&#39;;
    endScreen.style.display = &#39;none&#39;;
    isGameRunning = true;
    music.play();
    gameStartTime = Date.now();
    updateGame();
}

function endGame() {
    isGameRunning = false;
    cancelAnimationFrame(animationFrameId);
    finalScoreDisplay.textContent = `最終得分: ${score}`;
    endScreen.style.display = &#39;flex&#39;;
}

// Event Listeners
startButton.addEventListener(&#39;click&#39;, startGame);
restartButton.addEventListener(&#39;click&#39;, startGame);

// Setup input listeners for each lane
lanes.forEach((lane, index) =&gt; {
    const laneIndex = index;
    // For mobile touch
    lane.addEventListener(&#39;touchstart&#39;, (e) =&gt; {
        e.preventDefault(); // Prevent scrolling and other default behaviors
        handleInput(laneIndex);
    }, { passive: false });
    // For computer mouse click
    lane.addEventListener(&#39;mousedown&#39;, () =&gt; {
        handleInput(laneIndex);
    });
});

});
</script>
</body>
</html>
